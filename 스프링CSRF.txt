
csrf를 방어하기 위해선 csrf 공격에 대한 이해가 있으셔야 합니다..글쓴분은 아직 그 
공격이 어떤 상황의 공격인지는 이해를 못하신듯 하네요.. 

http://devblog.hanbit.co.kr/p/226 

이 글을 읽어보시면 csrf 공격이 어떤것인지 이해는 되실겁니다.. 
그러면 공격을 이해하면 이제 이것을 어떻게 방어해야 하는지를 고민해야 겠죠.. 
토큰 얘기는 이런겁니다.. 

webpage를 보여주기전에 세션에 암호화 문자열 생성 로직 같은것을 이용해 알아보기 
힘든 긴 문자열을 하나 저장한뒤 이 문자열을 webpage의 hidden 태그에 셋팅을 해줍니다..
단 이 문자열 생성규칙엔 조건이 있는데 매번 생성할때마다 다른 값이 나와야 합니다..
즉 암호화된 난수 문자열이 나와야 한다는거에요.. 

그리고 이 webpage가 submit 작업을 할때 hidden 태그에 셋팅된 암호화 된 문자열 
값과 세션에 저장된 암호화된 문자열 값을 비교해서 같은 값이면 정상적인 접근형태로 
이루어졌다고 보면 됩니다..왜냐? 해당 웹페이지를 보기 전에 난수로 만든 암호화된 
문자열을 서버 세션에 셋팅한 뒤에 그 문자열을 웹페이지에 내려보내줬고 클라이언트는 
그 문자열을 그대로 서버에 전송해줬으니까요..만약 csrf 공격을 했다면 저 문자열을 
비교하는 부분에 있어서 문제가 발생합니다..왜냐면 문자열은 매번 다르게 생성되니까 
설사 그 문자열까정 해킹되어서 얻었다한들..문자열 자체가 1회성 용도이기 때문에 한번 
사용되면 그 담에 재사용될 확률이 거의 없죠(0%라고 말할수는 없습니다..난수라 해도 
같은 수가 나올 확률..이란건 존재하는거니까요..) 

정리하자면.. 
1. 웹페이지를 보여주기전에 난수로 발생되는 암호화된 문자열을 세션에 셋팅한 뒤 
해당 웹페이지의 hidden 태그에도 그 암호화된 문자열을 셋팅해준다 
2. 해당 웹페이지에서 submit 발생시 hidden 태그에 셋팅된 문자열을 읽은 것과 세션에 
저장된 암호화된 문자열을 비교해서 일치하면 작업을 계속 진행하고 일치하지 않으면 
에러 페이지로 보낸다 

이렇게 됩니다..구현 방법은 어렵지는 않은데 문제는 이러한 작업을 모든 페이지에 
해줘야 한다는거죠..submit이라고 해서 post 방식으로만 해야겠구나 생각하실수도 
있겠으나 get 방식에서도 마찬가지입니다..get 방식에서도 파라미터로 읽어들이는 
부분이 있는거니까요.. 

그래서 이러한 보안적용을 할때 모든 페이지에 다 적용하느냐..아니면 중요도가 있는 
페이지를 대상으로 적용하느냐..에 대한 정책 결정도 필요합니다..그게 결정되어야 
작업의 범위가 정해지는거니까요..

>>>>>
필터로 검색 하시면 있습니다. 
모든 페이지에다가 히든값으로 넣어줘야 하긴 합니다. 
매 페이지마다 호출 시 난수 생성해서 필터에서 검증 합니다. 
테리님 말씀처럼 적용은 어렵지 않으나,매페이지마다 히든 값 넣어줘야 하긴 합니다..; 
저도 검색해서 구현 해 놓은게 있긴 한대 간혹가다가 난데없이 에러페이지가 나오기도 
하더군요;; 

>>>>>
https://code.google.com/p/csrf-filter/ 
web.xml 에 설정 하시고, 제외할 url 이나 액션들 제외시키고 설정 하시면 되요. 
클래스 파일은 source 에서 다운 받으시면 되요.. 
저는 클래스파일도 조금 수정한게 있어서 바로 클래스 파일 넣어놓고,xml 에 설정하고 
했네요.. 

>>>>>
csrf 관련해서 는 filter를 걸고 하는 방법이 있는데, 
form 마다 넣어줘야되요 hidden 변수에다가 해서요. 

그런데 이걸 걸어놓다보면 검색이라던지 이런데서 유입되는것도 막힐 수 있습니다. 

결재나 이런게 아니라면 어느정도 유연하게 풀어가시는게 좋지 않을까 싶습니다.